// src/util/wasteland_manager.rs
//! Wasteland Manager - Manages wasteland modules lifecycle
//! - Download from registry
//! - Install from disk/USB
//! - Update existing modules
//! - Archive modules
//! - Configure bindings and templates

use color_eyre::Result;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::fs;

/// Registry response format for module listings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryModule {
    pub id: String,
    pub name: String,
    pub description: String,
    pub version: String,
    pub author: String,
    pub module_type: String,
    pub template: String,
    pub download_url: String,
    pub checksum: String,
}

/// Registry API response
#[derive(Debug, Deserialize)]
pub struct RegistryResponse {
    pub modules: Vec<RegistryModule>,
    pub total: usize,
}

/// Module installation source
#[derive(Debug, Clone)]
pub enum InstallSource {
    Registry(String),           // module_id from registry
    LocalFile(PathBuf),         // Path to config.yml
    DiscoveredDevice(String),   // MAC address of BLE device
}

/// Wasteland Manager
pub struct WastelandManager {
    wasteland_path: PathBuf,
    archive_path: PathBuf,
    registry_url: String,
}

impl WastelandManager {
    pub fn new(wasteland_path: PathBuf) -> Self {
        let archive_path = wasteland_path.join(".archive");

        Self {
            wasteland_path,
            archive_path,
            registry_url: "https://registry.survon.io/v1".to_string(), // Mock for now
        }
    }

    /// Set custom registry URL
    pub fn set_registry_url(&mut self, url: String) {
        self.registry_url = url;
    }

    /// List available modules from registry
    pub async fn list_registry_modules(&self) -> Result<Vec<RegistryModule>> {
        // Mock implementation - in production, this would be:
        // let response = reqwest::get(format!("{}/modules", self.registry_url)).await?;
        // let registry: RegistryResponse = response.json().await?;
        // Ok(registry.modules)

        // For now, return mock data
        Ok(vec![
            RegistryModule {
                id: "pressure_monitor".to_string(),
                name: "Pressure Monitor".to_string(),
                description: "Monitor hydraulic or pneumatic pressure".to_string(),
                version: "1.0.0".to_string(),
                author: "Survon Community".to_string(),
                module_type: "monitoring".to_string(),
                template: "gauge_card".to_string(),
                download_url: format!("{}/modules/pressure_monitor/download", self.registry_url),
                checksum: "abc123".to_string(),
            },
            RegistryModule {
                id: "temperature_sensor".to_string(),
                name: "Temperature Sensor".to_string(),
                description: "Monitor ambient or equipment temperature".to_string(),
                version: "1.2.0".to_string(),
                author: "Survon Core".to_string(),
                module_type: "monitoring".to_string(),
                template: "gauge_card".to_string(),
                download_url: format!("{}/modules/temperature_sensor/download", self.registry_url),
                checksum: "def456".to_string(),
            },
            RegistryModule {
                id: "gate_controller".to_string(),
                name: "Gate Controller".to_string(),
                description: "Remote gate/door control".to_string(),
                version: "2.0.0".to_string(),
                author: "Survon Core".to_string(),
                module_type: "com".to_string(),
                template: "toggle_switch".to_string(),
                download_url: format!("{}/modules/gate_controller/download", self.registry_url),
                checksum: "ghi789".to_string(),
            },
        ])
    }

    /// Install a module from various sources
    pub async fn install_module(&self, source: InstallSource, custom_name: Option<String>) -> Result<String> {
        match source {
            InstallSource::Registry(module_id) => {
                self.install_from_registry(&module_id, custom_name).await
            }
            InstallSource::LocalFile(path) => {
                self.install_from_file(&path, custom_name).await
            }
            InstallSource::DiscoveredDevice(mac) => {
                // This is handled by DiscoveryManager, but we can create a placeholder
                Err(color_eyre::eyre::eyre!(
                    "Device modules are auto-generated by DiscoveryManager"
                ))
            }
        }
    }

    /// Install from registry
    async fn install_from_registry(&self, module_id: &str, custom_name: Option<String>) -> Result<String> {
        // Get module info from registry
        let modules = self.list_registry_modules().await?;
        let module = modules.iter()
            .find(|m| m.id == module_id)
            .ok_or_else(|| color_eyre::eyre::eyre!("Module not found in registry"))?;

        // Download module config (mock)
        // In production: reqwest::get(&module.download_url).await?

        // Create module directory
        let module_name = custom_name.unwrap_or_else(|| module.id.clone());
        let module_path = self.wasteland_path.join(&module_name);

        if module_path.exists() {
            return Err(color_eyre::eyre::eyre!("Module already exists"));
        }

        fs::create_dir_all(&module_path)?;

        // Generate config.yml based on registry template
        self.create_module_config(
            &module_path,
            &module.name,
            &module.module_type,
            &module.template,
            None,
        )?;

        Ok(module_name)
    }

    /// Install from local file
    async fn install_from_file(&self, source_path: &Path, custom_name: Option<String>) -> Result<String> {
        // Read existing config
        let config_content = fs::read_to_string(source_path)?;
        let config: serde_yaml::Value = serde_yaml::from_str(&config_content)?;

        // Extract module name
        let original_name = config.get("name")
            .and_then(|v| v.as_str())
            .ok_or_else(|| color_eyre::eyre::eyre!("Invalid config: missing name"))?;

        let module_name = custom_name.unwrap_or_else(|| {
            source_path
                .parent()
                .and_then(|p| p.file_name())
                .and_then(|n| n.to_str())
                .unwrap_or(original_name)
                .to_string()
        });

        let module_path = self.wasteland_path.join(&module_name);

        if module_path.exists() {
            return Err(color_eyre::eyre::eyre!("Module already exists"));
        }

        // Copy entire source directory
        if let Some(source_dir) = source_path.parent() {
            self.copy_dir_recursive(source_dir, &module_path)?;
        }

        Ok(module_name)
    }

    /// Update module configuration
    pub fn update_module_config(
        &self,
        module_name: &str,
        template: Option<String>,
        bindings: Option<serde_yaml::Mapping>,
    ) -> Result<()> {
        let config_path = self.wasteland_path.join(module_name).join("config.yml");

        if !config_path.exists() {
            return Err(color_eyre::eyre::eyre!("Module not found"));
        }

        // Read existing config
        let config_content = fs::read_to_string(&config_path)?;
        let mut config: serde_yaml::Mapping = serde_yaml::from_str(&config_content)?;

        // Update template if provided
        if let Some(template) = template {
            config.insert(
                serde_yaml::Value::String("template".to_string()),
                serde_yaml::Value::String(template),
            );
        }

        // Update bindings if provided
        if let Some(new_bindings) = bindings {
            config.insert(
                serde_yaml::Value::String("bindings".to_string()),
                serde_yaml::Value::Mapping(new_bindings),
            );
        }

        // Write back
        let updated_content = serde_yaml::to_string(&config)?;
        fs::write(&config_path, updated_content)?;

        Ok(())
    }

    /// Archive a module (move to .archive folder)
    pub fn archive_module(&self, module_name: &str) -> Result<()> {
        let module_path = self.wasteland_path.join(module_name);

        if !module_path.exists() {
            return Err(color_eyre::eyre::eyre!("Module not found"));
        }

        // Create archive directory if needed
        fs::create_dir_all(&self.archive_path)?;

        // Generate unique archive name with timestamp
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_secs();
        let archive_name = format!("{}_{}", module_name, timestamp);
        let archive_dest = self.archive_path.join(&archive_name);

        // Move to archive
        fs::rename(&module_path, &archive_dest)?;

        Ok(())
    }

    /// List archived modules
    pub fn list_archived_modules(&self) -> Result<Vec<String>> {
        if !self.archive_path.exists() {
            return Ok(Vec::new());
        }

        let entries = fs::read_dir(&self.archive_path)?
            .filter_map(|e| e.ok())
            .filter(|e| e.path().is_dir())
            .map(|e| e.file_name().to_string_lossy().to_string())
            .collect();

        Ok(entries)
    }

    /// Restore a module from archive
    pub fn restore_module(&self, archive_name: &str, new_name: Option<String>) -> Result<()> {
        let archive_source = self.archive_path.join(archive_name);

        if !archive_source.exists() {
            return Err(color_eyre::eyre::eyre!("Archived module not found"));
        }

        // Extract original name (remove timestamp suffix)
        let original_name = archive_name.split('_')
            .next()
            .unwrap_or(archive_name);

        let restore_name = new_name.unwrap_or_else(|| original_name.to_string());
        let restore_dest = self.wasteland_path.join(&restore_name);

        if restore_dest.exists() {
            return Err(color_eyre::eyre::eyre!("Module already exists"));
        }

        // Move back from archive
        fs::rename(&archive_source, &restore_dest)?;

        Ok(())
    }

    /// Create a new module config from scratch
    fn create_module_config(
        &self,
        module_path: &Path,
        name: &str,
        module_type: &str,
        template: &str,
        bindings: Option<serde_yaml::Mapping>,
    ) -> Result<()> {
        let config_path = module_path.join("config.yml");

        let mut config = serde_yaml::Mapping::new();
        config.insert(
            serde_yaml::Value::String("name".to_string()),
            serde_yaml::Value::String(name.to_string()),
        );
        config.insert(
            serde_yaml::Value::String("module_type".to_string()),
            serde_yaml::Value::String(module_type.to_string()),
        );
        config.insert(
            serde_yaml::Value::String("bus_topic".to_string()),
            serde_yaml::Value::String(name.to_lowercase().replace(" ", "_")),
        );
        config.insert(
            serde_yaml::Value::String("template".to_string()),
            serde_yaml::Value::String(template.to_string()),
        );

        // Add default bindings
        let default_bindings = bindings.unwrap_or_else(|| {
            let mut b = serde_yaml::Mapping::new();
            b.insert(
                serde_yaml::Value::String("is_blinkable".to_string()),
                serde_yaml::Value::Bool(true),
            );
            b
        });

        config.insert(
            serde_yaml::Value::String("bindings".to_string()),
            serde_yaml::Value::Mapping(default_bindings),
        );

        let yaml_content = serde_yaml::to_string(&config)?;
        fs::write(config_path, yaml_content)?;

        Ok(())
    }

    /// Recursive directory copy helper
    fn copy_dir_recursive(&self, src: &Path, dst: &Path) -> Result<()> {
        fs::create_dir_all(dst)?;

        for entry in fs::read_dir(src)? {
            let entry = entry?;
            let path = entry.path();
            let dest_path = dst.join(entry.file_name());

            if path.is_dir() {
                self.copy_dir_recursive(&path, &dest_path)?;
            } else {
                fs::copy(&path, &dest_path)?;
            }
        }

        Ok(())
    }
}
